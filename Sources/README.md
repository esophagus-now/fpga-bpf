Brief summary of each file:

- **`alu.v`**: The dumbest ALU on Earth. Instantiated inside `bpfvm_datapath.v` as part of the CPU core.
- **`bpfcpu.v`**: Simply wires up `bpfvm_ctrl.v` and `bpfvm_ctrl.v` into one module, exporting only the memory interfaces.
- **`bpfvm.v`**: Top-level file which instantiates `bpfcpu.v`, `packetmem.v`, and `codemem.v`
- **`bpfvm_ctrl.v`**: An FSM controller for the CPU core. I may pipeline this controller one day.
- **`bpfvm_datapath.v`**: The BPF CPU core's datapath. This instantiates `alu.v` and `regfile.v`
- **`codemem.v`**: Very simple wrapper around `coderam.v`. Its only purpose is to have an interface with a read enable and write enable, instead of a global enable and a write enable. (Note to self: this is ridiculous, and you should probably get rid of it). Used as the CPU's instruction memory.
- **`coderam.v`**: A simple Verilog file synthesized as a BRAM in simple dual-port mode. Instantiated in `codemem.v`
- **`cpuqueue.v`**: The "job queue" for the CPU. This is used as part of `p3ctrl.v`.
- **`fwdqueue.v`**: The "job queue" for the forwarder. This is used as part of `p3ctrl.v`.
- **`muxselinvert.v`**: Given the memory buffer choices for the snooper, CPU, and forwarder, it automatically determines the agent selections for each of the ping/pang/pung buffers. This is part of `painfulmuxes.v`, which is used inside `packetmem.v`
- **`p3ctrl.v`**: The "ping/pang/pung controller". Essentially, it arbitrates which of the snooper, cpu, and forwarder gets to use which of the ping, pang, or pung buffers. All it does is instantiate `{sn,cpu,fwd}queue.v` (no, I don't think this is a good name, but I haven't really thought of anything better)
- **`packetmem.v`**: Probably the most fiddly module. Essentially it instantiates `p3ctrl.v`, `painfulmuxes.v`, and three `packetram.v` modules. It also instantiates `read_size_adapter.v` in order to connect the CPU's slightly different interface to the common `packetram.v` interface.
- **`packetram.v`**: Slightly unusual BRAM designed for use in `packetmem.v`. It uses 32bit word aligned addresses, but returns the 64 bits starting at that location. That is, if you ask for `mem[addr]`, it will return the 32 bit words at `mem[addr]` and `mem[addr+1]`. This bizarre choice is a kludge in order to enable variable-sized and possibly unaligned reads from the CPU.
- **`painfulmuxes.v`**: Given the inputs/outputs on the snooper, cpu, forwarder, ping, pang, and pung, as well as the MUX select lines (which are generated by the `p3ctrl.v` instantiated in `packetmem.v`), it correctly connects the right inputs to the right outputs.
- **`read_size_adapter.v`**: This takes a byte address from the CPU, converts it to the correct 32 bit read address for a `packetram.v`, then takes the 64 bits of output from the memory, and (depending on the read size specified by the CPU) cuts out just the part the CPU wants. It outputs a 32 bit number, which is left-padded with zeros when necessary.
- **`regfile.v`**: A simple register file (instantiated in `bpfvm_datapath.v`) implemented as distributed RAM.
- **`snqueue.v`**: The "job queue" for the snooper. This is used as part of `p3ctrl.v`.

Refer to the Wiki for a high-level view of how these modules are all connected together. Also, the files themselves have some extra details in the comments at the top.
