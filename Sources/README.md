Here, the folder hierarchy mimics the actual design hierarchy. For example, the ALU is inside the datapath (which is inside the CPU \[which is inside the VM\]). So, the path to `alu.v` is `BPFVM/CPU/datapath/alu.v`. The "top-level module" for each "level" of the hierarchy is included inside its own folder. For example, `datapath.v` (even though it is the parent of `alu.v`) is inside `BPFVM/CPU/datapath/datapath.v`.

Brief summary of each file (sorted by alphabetical order of the filename, not the path):

- **`BPFVM/CPU/datapath/alu.v`**: The dumbest ALU on Earth. Instantiated inside `bpfvm_datapath.v` as part of the CPU core.
- **`Forwarders/axistream_forwarder.v`**: Bridges the forwarder BRAM interface on `bpfvm.v` to an AXI Stream output. This file is used inside `axistream_packetfilt.v`.
- **`axistream_packetfilt.v`**: One particular variation of the packet filter. This takes the BPFVM (in an instantiation of `packetfilt.v`) and hooks it up with an AXILite interface (using `packet_filter_regs.sv`), and an AXI Stream snooper and forwarder (which are in `Snoopers/axistream_snooper.v` and `Snoopers/axistream_forwarder.v`).
- **`Snoopers/axistream_snooper.v`**: Snoops on an AXI Stream (with TLAST) bus, and writes into the snooper interface on `bpfvm.v`. This file is used inside `axistream_packetfilt.v`.
- **`BPFVM/CPU/bpfcpu.v`**: Simply wires up `bpfvm_ctrl.v` and `bpfvm_datapath.v` into one module, exporting only the memory interfaces.
- **`bpf_defs.vh`**: Common place for all the `define`s use in the other files
- **`BPFVM/bpfvm.v`**: Top-level file which instantiates `bpfcpu.v`, `packetmem.v`, and `codemem.v`
- **`BPFVM/CPU/bpfvm_ctrl.v`**: An FSM controller for the CPU core. I may pipeline this controller one day.
- **`BPFVM/CPU/bpfvm_datapath.v`**: The BPF CPU core's datapath. This instantiates `alu.v` and `regfile.v`
- **`BPFVM/codemem/codemem.v`**: Very simple wrapper around `coderam.v`. Its only purpose is to have an interface with a read enable and write enable, instead of a global enable and a write enable. (Note to self: this is ridiculous, and you should probably get rid of it). Used as the CPU's instruction memory.
- **`BPFVM/codemem/coderam.v`**: A simple Verilog file synthesized as a BRAM in simple dual-port mode. Instantiated in `codemem.v`
- **`BPFVM/packetmem/p3ctrl/cpuqueue.v`**: The "job queue" for the CPU. This is used as part of `p3ctrl.v`.
- **`BPFVM/packetmem/p3ctrl/fwdqueue.v`**: The "job queue" for the forwarder. This is used as part of `p3ctrl.v`.
- **`BPFVM/packetmem/muxes/muxselinvert.v`**: Given the memory buffer choices for the snooper, CPU, and forwarder, it automatically determines the agent selections for each of the ping/pang/pung buffers. This is part of `painfulmuxes.v`, which is used inside `packetmem.v`
- **`BPFVM/packetmem/p3ctrl/p3ctrl.v`**: The "ping/pang/pung controller". Essentially, it arbitrates which of the snooper, cpu, and forwarder gets to use which of the ping, pang, or pung buffers. All it does is instantiate `{sn,cpu,fwd}queue.v` (no, I don't think this is a good name, but I haven't really thought of anything better)
- **`packet_filter_regs.sv`** and **`packet_filter_regs_pkg.sv`**: Files generated by AirHDL, used to make an AXILite interface to the packet filter. These files are instantiated in `packetfilt.v`.
- **`packetfilt.v`**: Simply wires up an AXILite interface (with `packet_filter_regs.sv` via `regstrb2mem.v`) to `bpfvm.v`. This is intended to be a general top-level module, though `axistream_packetfilt.v` instantiates this module along with an AXI Stream snooper and forwarder.
- **`BPFVM/packetmem/packetmem.v`**: Probably the most fiddly module. Essentially it instantiates `p3ctrl.v`, `painfulmuxes.v`, and three `packetram.v` modules. It also instantiates `read_size_adapter.v` in order to connect the CPU's slightly different interface to the common `packetram.v` interface.
- **`BPFVM/packetmem/packetram.v`**: Slightly unusual BRAM designed for use in `packetmem.v`. It uses 32bit word aligned addresses, but returns the 64 bits starting at that location. That is, if you ask for `mem[addr]`, it will return the 32 bit words at `mem[addr]` and `mem[addr+1]`. This bizarre choice is a kludge in order to enable variable-sized and possibly unaligned reads from the CPU.
- **`BPFVM/packetmem/muxes/painfulmuxes.v`**: Given the inputs/outputs on the snooper, cpu, forwarder, ping, pang, and pung, as well as the MUX select lines (which are generated by the `p3ctrl.v` instantiated in `packetmem.v`), it correctly connects the right inputs to the right outputs.
- **`BPFVM/packetmem/read_size_adapter.v`**: This takes a byte address from the CPU, converts it to the correct 32 bit read address for a `packetram.v`, then takes the 64 bits of output from the memory, and (depending on the read size specified by the CPU) cuts out just the part the CPU wants. It outputs a 32 bit number, which is left-padded with zeros when necessary.
- **`BPFVM/CPU/datapath/regfile.v`**: A simple register file (instantiated in `bpfvm_datapath.v`) implemented as distributed RAM.
- **`regstrb2mem.v`**: The AirHDL files essentially bridge AXILite to a simple register+strobe interface. This file bridges between register and strobe to the BRAM memory interface on `codemem.v`, and is used inside `packetfilt.v`
- **`BPFVM/packetmem/p3ctrl/snqueue.v`**: The "job queue" for the snooper. This is used as part of `p3ctrl.v`.

Here's a quick diagram showing the connections (slightly more detail on the Wiki)
![test image](https://raw.githubusercontent.com/esophagus-now/fpga-bpf/nodiv/Figures/Verilog%20Modules%20(detailed).png)
